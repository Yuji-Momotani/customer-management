# 実装計画: LINE LIFF 予約システム

**ブランチ**: `001-line-liff-next` | **日付**: 2025-09-22 | **仕様**: [spec.md](./spec.md)
**入力**: 機能仕様書 `/specs/001-line-liff-next/spec.md`

## 実行フロー (/planコマンドスコープ)
```
1. 入力パスから機能仕様書をロード
   → 見つからない場合: エラー "機能仕様書が{path}にありません"
2. 技術的文脈を記入（要明確化をスキャン）
   → コンテキストからプロジェクトタイプを検出（web=フロントエンド+バックエンド、mobile=アプリ+API）
   → プロジェクトタイプに基づく構造決定を設定
3. 憲法文書の内容に基づいて憲法チェックセクションを記入
4. 以下の憲法チェックセクションを評価
   → 違反が存在する場合: 複雑性追跡に文書化
   → 正当化が不可能な場合: エラー "まずアプローチを簡素化"
   → 進捗追跡を更新: 初期憲法チェック
5. フェーズ0を実行 → research.md
   → 要明確化が残っている場合: エラー "不明点を解決"
6. フェーズ1を実行 → contracts、data-model.md、quickstart.md、エージェント固有テンプレートファイル
7. 憲法チェックセクションを再評価
   → 新しい違反がある場合: 設計をリファクタリング、フェーズ1に戻る
   → 進捗追跡を更新: 設計後憲法チェック
8. フェーズ2を計画 → タスク生成アプローチを説明（tasks.mdは作成しない）
9. 停止 - /tasksコマンドの準備完了
```

**重要**: /planコマンドはステップ7で停止します。フェーズ2-4は他のコマンドで実行：
- フェーズ2: /tasksコマンドがtasks.mdを作成
- フェーズ3-4: 実装実行（手動またはツールによる）

## 概要
LINE LIFF予約システムはユーザーがLINEミニアプリ経由でサービスを予約できるようにします。主要機能にはサービス閲覧、時間枠選択、LINE通知による予約確認、予約管理があります。既存のNext.js + TypeScript + LIFF基盤上に構築されます。

## 技術的文脈
**言語/バージョン**: TypeScript (Next.jsフレームワーク)  
**主要依存関係**: Next.js、@line/liff、React、Prisma ORM  
**ストレージ**: PostgreSQL  
**テスト**: Jest + Testing Library + Playwright  
**対象プラットフォーム**: LINE LIFF（LINEメッセンジャー内のWebベースミニアプリ）
**プロジェクトタイプ**: web - フロントエンド + バックエンドAPI  
**パフォーマンス目標**: 1000同時ユーザー、300ms未満の応答時間  
**制約**: LINE LIFFプラットフォーム制限、モバイルレスポンシブデザイン必須  
**規模/スコープ**: 中小企業予約システム、日単位100-500予約、50-100同時ユーザー

## 憲法チェック
*ゲート: フェーズ0調査前に合格必須。フェーズ1設計後に再チェック。*

**憲法分析**: 憲法テンプレートはプレースホルダー形式を示している - このプロジェクト用の具体的な原則はまだ定義されていません。標準的な開発慣行を仮定：
- ✅ 既存のNext.js基盤上に構築（不要な新フレームワークを作成しない）
- ✅ TypeScriptが型安全性を提供
- ✅ 実装前にテストを書くTDDアプローチに従う
- ✅ 既存のLIFF統合を使用（プラットフォーム統合を再発明しない）

**ステータス**: 合格 - 憲法違反は特定されませんでした

## プロジェクト構造

### ドキュメント（この機能）
```
specs/001-line-liff-next/
├── plan.md              # このファイル（/planコマンド出力）
├── research.md          # フェーズ0出力（/planコマンド）
├── data-model.md        # フェーズ1出力（/planコマンド）
├── quickstart.md        # フェーズ1出力（/planコマンド）
├── contracts/           # フェーズ1出力（/planコマンド）
└── tasks.md             # フェーズ2出力（/tasksコマンド - /planでは作成されない）
```

### ソースコード（リポジトリルート）
```
# オプション1: 単一プロジェクト（デフォルト）
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# オプション2: Webアプリケーション（"フロントエンド" + "バックエンド"検出時）
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# オプション3: モバイル + API（"iOS/Android"検出時）
api/
└── [上記のバックエンドと同じ]

ios/ または android/
└── [プラットフォーム固有の構造]
```

**構造決定**: オプション2（Webアプリケーション） - Next.jsフロントエンド + APIルートバックエンド

## フェーズ0: アウトライン & 調査
1. **上記の技術的文脈から不明点を抽出**:
   - 各要明確化 → 調査タスク
   - 各依存関係 → ベストプラクティスタスク
   - 各統合 → パターンタスク

2. **調査エージェントを生成・派遣**:
   ```
   技術的文脈の各不明点について:
     タスク: "{機能コンテキスト}での{不明点}を調査"
   各技術選択について:
     タスク: "{ドメイン}での{技術}のベストプラクティスを見つける"
   ```

3. **research.mdでの調査結果を統合** 以下の形式を使用:
   - 決定: [選択されたもの]
   - 根拠: [選択理由]
   - 検討した代替案: [評価した他の選択肢]

**出力**: すべての要明確化が解決されたresearch.md

## フェーズ1: 設計 & 契約
*前提条件: research.md完了*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - エンティティ名、フィールド、関係性
   - 要件からの検証ルール
   - 該当する場合の状態遷移

2. **機能要件からAPI契約を生成**:
   - 各ユーザーアクション → エンドポイント
   - 標準的なREST/GraphQLパターンを使用
   - OpenAPI/GraphQLスキーマを`/contracts/`に出力

3. **契約から契約テストを生成**:
   - エンドポイントごとに1テストファイル
   - リクエスト/レスポンススキーマをアサート
   - テストは失敗する必要がある（まだ実装なし）

4. **ユーザーストーリーからテストシナリオを抽出**:
   - 各ストーリー → 統合テストシナリオ
   - クイックスタートテスト = ストーリー検証ステップ

5. **エージェントファイルを段階的に更新**（O(1)操作）:
   - `.specify/scripts/bash/update-agent-context.sh claude`を実行
     **重要**: 上記の通り正確に実行してください。引数を追加・削除しないでください。
   - 存在する場合: 現在の計画から新しい技術のみを追加
   - マーカー間の手動追加を保持
   - 最近の変更を更新（最新3つを保持）
   - トークン効率のため150行以下に保持
   - リポジトリルートに出力

**出力**: data-model.md、/contracts/*、失敗するテスト、quickstart.md、エージェント固有ファイル

## フェーズ2: タスク計画アプローチ
*このセクションでは/tasksコマンドが行うことを説明 - /plan中は実行しない*

**タスク生成戦略**:
- `.specify/templates/tasks-template.md`をベースとしてロード
- フェーズ1設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- 各APIエンドポイント → 契約テストタスク [P]
- 各エンティティ（User、Service、TimeSlot、Reservation） → モデル作成タスク [P] 
- 各ユーザーシナリオ → 統合テストタスク
- LINE LIFF統合タスク
- データベースセットアップとマイグレーションタスク
- テストを通すための実装タスク

**順序戦略**:
- TDD順序: 実装前にテスト 
- 依存関係順序: データベース → モデル → API → フロントエンド → 統合
- 独立ファイルに[P]マークで並列実行
- 関連タスクをグループ化（例：すべての予約機能を一緒に）

**具体的タスクカテゴリ**:
1. **データベースセットアップ**（1-2タスク）: Prismaスキーマ、マイグレーション
2. **モデルテスト**（4タスク - エンティティごと）: データ検証用契約テスト
3. **APIテスト**（5タスク）: 各APIエンドポイントグループ用契約テスト
4. **LIFF統合**（3タスク）: 認証、プロフィール、メッセージング
5. **フロントエンドコンポーネント**（8-10タスク）: サービス一覧、予約フォーム、予約管理
6. **統合テスト**（5タスク）: クイックスタートからのエンドツーエンドユーザーシナリオ
7. **実装**（15-20タスク）: すべてのテストを通す

**推定出力**: tasks.mdに35-40の番号付き順序タスク

**重要**: このフェーズは/tasksコマンドで実行され、/planでは実行されません

## フェーズ3+: 将来の実装
*これらのフェーズは/planコマンドのスコープ外*

**フェーズ3**: タスク実行（/tasksコマンドがtasks.mdを作成）  
**フェーズ4**: 実装（憲法原則に従ってtasks.mdを実行）  
**フェーズ5**: 検証（テスト実行、quickstart.md実行、パフォーマンス検証）

## 複雑性追跡
*憲法チェックに正当化が必要な違反がある場合のみ記入*

| 違反 | 必要な理由 | より簡単な代替案が拒否された理由 |
|-----------|------------|-------------------------------------|
| [例：4番目のプロジェクト] | [現在のニーズ] | [3つのプロジェクトでは不十分な理由] |
| [例：リポジトリパターン] | [具体的な問題] | [直接DB接続では不十分な理由] |


## 進捗追跡
*この チェックリストは実行フロー中に更新される*

**フェーズステータス**:
- [x] フェーズ0: 調査完了（/planコマンド）
- [x] フェーズ1: 設計完了（/planコマンド）
- [x] フェーズ2: タスク計画完了（/planコマンド - アプローチのみ説明）
- [ ] フェーズ3: タスク生成完了（/tasksコマンド）
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲートステータス**:
- [x] 初期憲法チェック: 合格
- [x] 設計後憲法チェック: 合格
- [x] すべての要明確化解決済み
- [ ] 複雑性逸脱文書化済み

---
*憲法v2.1.1に基づく - `/memory/constitution.md`を参照*